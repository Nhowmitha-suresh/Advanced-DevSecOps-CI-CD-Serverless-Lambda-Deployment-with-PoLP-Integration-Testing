name: CI/CD Pipeline - Staging

on:
  push:
    branches: [ main ] # Trigger on push to main

env:
  STAGING_FUNCTION_NAME: serverless-staging-api # Name of the existing Staging Lambda function
  REGION: us-east-1 # Target AWS Region
  ZIP_FILE: deployment_package.zip # Artifact filename

jobs:
  build_test_and_deploy:
    runs-on: ubuntu-latest
    # Target the Staging environment (Requires environment setup in GitHub settings)
    environment: Staging
    
    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      # üöÄ 3. Cache Dependencies (Performance Optimization)
      - name: Restore Node Modules Cache
        id: cache-npm
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
            
      - name: Install dependencies
        if: steps.cache-npm.outputs.cache-hit != 'true' # Only run if cache miss
        run: npm ci
        
      - name: 4. Run Unit Tests (CI)
        run: npm test

      # ‚öôÔ∏è 5. Configure AWS Credentials (Least Privilege)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: 6. Package Application Artifact
        # Package code and node_modules into a zip file
        run: zip -r ${{ env.ZIP_FILE }} . -x '*.git*' '*.github*'
        
      - name: 7. Deploy to AWS Lambda (CD - AWS CLI)
        id: deploy
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.STAGING_FUNCTION_NAME }} \
            --zip-file fileb://${{ env.ZIP_FILE }} \
            --region ${{ env.REGION }}
          
          # Retrieve the Function URL for the next job's integration test
          FUNCTION_URL=$(aws lambda get-function-url-config \
            --function-name ${{ env.STAGING_FUNCTION_NAME }} \
            --region ${{ env.REGION }} \
            --query 'FunctionUrl' --output text)
          
          # Set the URL as an environment variable for the next job
          echo "STAGING_URL=$FUNCTION_URL" >> $GITHUB_ENV
          
    outputs:
      STAGING_URL: ${{ env.STAGING_URL }} # Pass the URL to the Integration Test job

  integration_test:
    needs: build_test_and_deploy
    runs-on: ubuntu-latest
    # Uses the Staging environment context
    environment: Staging
    
    steps:
      # üß™ 8. Automated Integration Test
      - name: Test Deployed Endpoint
        run: |
          STAGING_URL="${{ needs.build_test_and_deploy.outputs.STAGING_URL }}"
          echo "Testing live endpoint: $STAGING_URL"
          
          # Use curl to check for status 200
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $STAGING_URL)
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ Integration Test Passed: Status 200 received."
          else
            echo "‚ùå Integration Test Failed: Received status $HTTP_CODE."
            exit 1
          fi